.nf
.P Product Version     22.14    Cadence Design Systems, Inc. 
.fi
.TH uniquify  22.14 "Fri Oct 06 02:12:27 2023" 
.SH Name \fBuniquify\fR \-  Supports regrouping of master-clone partitions inside the non-unique modules. This command uniquifies or regroups the master/clones (one master module used by two or more hinst clones) by creating unique modules for each hinst clone, as needed
.SH Syntax \fBuniquify\fR  [-help]  {[<design> | <module>] | -new_master <hinsts>} [-exclude <modules>]  [-verbose]
.P Supports regrouping of master-clone partitions inside the non-unique modules. This command uniquifies or regroups the master/clones (one master module used by two or more hinst clones) by creating unique modules for each hinst clone, as needed. In all the cases, the new module names are generated by appending the '_number' suffix (such as _1 and _2) sequentially to the original module name for creating a unique module name. 
.SH Parameters    "\fB-help\fR" Prints a brief description that includes the type and default information for each uniquify parameter.  For a detailed description of the command and all its parameters, use the man command:  man uniquify  "\fB<design> | <module>  \fR" Regroups the master/clones within the <design> or <module> and recursively below it. This assures that all the hinsts inside those would have their own unique module, except for the modules specified using the -exclude parameter. In case multiple hinsts are referenced to the specified module, those will remain as clones.  Type: Mandatory  "\fB-new_master <hinsts>\fR" Splits the hinst clones of a master module into the clones of a new master. The new master is also regrouped, except for the modules specified using the -exclude parameter. It may also happen that one of such hinst clones is forced to have a new master (refer to the Examples section). In case a hinst is not a clone of the same module, an error message is displayed.  Type: Mandatory  "\fB-exclude <modules>  \fR" Excludes the specified modules from unification or regrouping. Use this parameter if a specific sub-module is a partition, which will be implemented and shared only once.  Type: Optional  "\fB[-verbose]  \fR" Reports the hinst clones (if any), which are regrouped.  Type: Optional 
.SH Examples
.RS  "*" 2  The following command uniquifies the whole design, where the h1, h2, and h3 hinsts are clones of the mod1 module, and the h4 and h5 hinsts (clones of the mod2 module) are inside mod1:  uniquify top -verbose   #hinst name module name  h1 mod1 (unchanged)  h2 mod1_1  h3 mod1_2  h1/h4 mod2 (unchanged)  h1/h5 mod2_1  h2/h4 mod2_2  h2/h5 mod2_3  h3/h4 mod2_4  h3/h5 mod2_5  Note that the first clone of each module is not modified. So, h1 still uses mod1, and h1/h4 still use mod2. However, these are still reported to see the hinst clone, which forces a new module for the other hinst clones.  "*" 2  Using the same scenario as in the previous example, the following command uniquifes the design below mod1:  uniquify mod1 -verbose  #hinst name module name  h1/h4 mod2 (unchanged)  h1/h5 mod2_1  h2/h4 mod2 (unchanged)  h2/h5 mod2_1  h3/h4 mod2 (unchanged)  h3/h5 mod2_1  Note that only the design inside mod1 is uniquified. So, h1, h2, and h3 are still the clones of mod1, and there are still master/clones grouping between h1, h2, and h3. For instance, all the h4s use mod2, and all the h5s use mod2_1.  "*" 2  Using the same scenario as in the first example, the following command splits h1 and h2 into a new master. This is normally done, if h1, h2, and h3 are partitions and need a different implementation than h3. It is recommended not to uniquify mod2, if it is a lower-level partition, which will be implemented once and shared by all h1, h2, and h3.  uniquify -new_master {h1 h2} -exclude mod2 -verbose  #hinst name module name  h1 mod1_1  h2 mod1_1  Note that h3 is still using mod1, and the mod2 hinsts inside mod1 and mod1_1 (such as h4 and h5) are still the clones of mod2. If there is also a mod3 inside mod1, it will also be uniquified, but nothing inside mod2 is uniquified.  "*" 2  Using the same scenario as in the first example, the following command splits h1 and h4 into a new master. This implicitly forces h1 to be uniquified from h2 and h3.  uniquify -new_master {h1/h4} -verbose  #hinst name module name  h1 mod1_1 (forced by lower level change)  h1/h4 mod2_1  If there is a mod4 inside mod2_1, it will also be uniquified, but it will not be shared with mod2.
.RE
.P
