.nf
.P Product Version     22.14    Cadence Design Systems, Inc. 
.fi
.TH routeDesign  22.14 "Fri Oct 06 02:12:27 2023" 
.SH Name \fBrouteDesign\fR \-  Runs routing or postroute via or wire optimization using the NanoRoute router
.SH Syntax \fBrouteDesign\fR  [-help]   [-backside]  [-bump]  [-highFrequency]  [-selected]  [-viaPillarOpt]   [[[-clockEco ] [-globalDetail ]     [-placementCheck | -noPlacementCheck ]     [[ -trackOpt ] [-idealClock ]]     [-viaOpt ] [-wireOpt ]] | [-passiveFill ]]
.P Runs routing or postroute via or wire optimization using the NanoRoute router. If you specify this command without any arguments, it runs global and detailed routing.
.P The routeDesign command has the following characteristics:
.RS  "*" 2 It supports multiple-CPU processing.   "*" 2 It checks for conflicts in option settings and issues warning messages when it finds problems. For example, trying to fix postroute lithography problems and optimize vias concurrently can cause conflicts.   If routeDesign detects requests for both types of operation, it issues a warning, turns off via optimization, and proceeds with fixing lithography problems.  "*" 2 It honors all setNanoRouteMode settings that do not have conflicts  "*" 2 routeDesign is a super command that handles the setting of NanoRoute variables so that it is run in timing-driven mode then sets them back postRoute. It runs SMART routing by default; that is, it runs in both timing- and signal integrity-driven mode by default.  Note: The other routing commands are not timing- or signal-integrity driven by default, but you can use the following setNanoRouteMode parameters to turn on timing- and signal-integrity-driven routing for those commands:  To turn on timing-driven routing, run the following command before running routeDesign:   setNanoRouteMode -routeWithTimingDriven true  To turn on SI-driven routing, run the following command before running routeDesign:   setNanoRouteMode -routeWithSIDriven true  If you run either (or both) of these commands, the software stores the mode settings in the
.mode file. If you restore the design and run routeDesign again, it honors the these settings. For example, if you type the following commands, the next time you restore the design and run routeDesign, it routes the design in timing-driven mode:  setNanoRouteMode -routeWithTimingDriven true  routeDesign -globalDetail  saveDesign  "*" 2 It updates the timing file automatically after all the nets are detail routed in timing-driven mode. Updating the file ensures that critical nets are not touched during postroute multiple-cut via swap, wire spreading and wire widening. When determining whether all the nets are detail routed, the router skips pins without physical ports.  "*" 2 It runs a placement check prior to routing and displays a warning message if the placement is not clean.   "*" 2 To turn off the placement check, specify the following parameter: -noPlacementCheck  "*" 2 It changes the status of clock nets from FIXED to ROUTED so it can modify them during routing and routes them before routing other nets. Once the status of the clock nets is set to ROUTED, it does not change it back to FIXED.  To keep clock nets' status FIXED, run the following command before running routeDesign:   setNanoRouteMode -routeDesignFixClockNets true  To stop the router from routing clock nets first, run the following command before running routeDesign:   setNanoRouteMode -routeDesignRouteClockNetsFirst false
.RE
.P Note: You can use the check_design -type route command  to detect the potential problems and correct the design before running the routeDesign command
.RS  "*" 2 For issues related to unplaced instances that clearly affect routing, the check_design command displays error messages and returns a status to discontinue the flow. You must resolve the issue before continuing to the route phase.  "*" 2 For issues related to adherence to the track rules, the check_design command checks the design. It currently makes a basic check that the structures needed for routing adhere to the tracking rules before routing begins.  "*" 2 For issues related to unplaced top level pins that clearly affect routing, the check_design command displays error messages and returns a status to discontinue the flow. You must resolve the issue before continuing to the route phase.  "*" 2 For issues related to adherence to the third party routing rules, the check_design command checks the design for metal violations. If the design is taped out or known to be clean, the presence of violations represents a discrepancy between the design and the tech.lef. It normally indicates that the tech may be of the wrong version or may need to be updated to the technology that the design was taped out using. These issues must be understood in detail and waved individually and on purpose by changing the tech.lef before continuing to the route phase.   "*" 2  For issues related to overlapping cells that clearly affect routing, the check_design command displays error messages and returns a status to discontinue the flow. You must resolve the issue before continuing to the route phase.  "*" 2 For issues related pin spacing violations, the check_design command checks if the pin has a spacing violation with the same cell or a different metal cell. It checks macro pin related spacing violations and runs the verify_drc command to catch spacing issues that may block the pin access.You must resolve the issue before continuing to the route phase.  "*" 2  For issues related to routing congestion, the check_design command checks the NanoRoute congestion table and reports the congestion in the NanoRoute log format (with the information that the source is NanoRoute Global). Alternatively, it reports the Early Global Route congestion in the NanoRoute format. By default, the check_design command stops if the Worst Over Congested Gcell is above 0.75%. Even though these issues can be ignored, it is recommended that you understand them in detail and wave them individually before continuing to the route phase.   "*" 2 For issues related to a blockage between the pin and the attribute constraint layer at the pin location, the check_design command displays error messages and returns a status to discontinue the flow. You must resolve the issue before continuing to the route phase.   "*" 2 For issues related to pre-existing violations in ECO routing, the check_design command runs the verify_drc command and then checks the results for routing wire DRC and ignores non-routing wire DRC. If any metal violation is found, the check_design command displays error messages and returns a status to discontinue the flow. You must resolve the issue before continuing with ECO routing.  "*" 2 For issues related to adherence to the third party routing rules, the check_design command checks the design for metal violations. If the design is taped out or known to be clean, the presence of violations represents a discrepancy between the design and the tech.lef. It normally indicates that the tech may be of the wrong version or may need to be updated to the technology that the design was taped out using. These issues must be understood in detail and waved individually and on purpose by changing the tech.lef before continuing to the route phase.   "*" 2 For issues related to unplaced top level pins that clearly affect routing, the check_design command displays error messages and returns a status to discontinue the flow. You must resolve the issue before continuing to the route phase.  "*" 2 For issues related to pin access for non-default rules, the check_design command checks each NDR nets output pin for two-cut APA accessibility. For macros, it checks if the pin width is less than or equal to the NDR. The check_design command displays error messages if the NDR is hard or if the no taper property is set to true. You must resolve the issue before continuing to the route phase. 
.RE 
.SH Parameters   "\fB-backside\fR" Routes back side layers only. The NanoRoute router supports back side routing for the layers defined as "BACKSIDE" in LEF and cell library pins.  When the -backside parameter is enabled, the router connects the pins in the back side layers only.  Note: Back side routing layer has the BACKSIDE LEF property assigned to it. The back side rule is used to specify that the routing layer is used on the underside of the die.  Data_type: bool, optional  "\fB-bump\fR" Enables interposer routing to connect the macro bumps with bus routing patterns.  Note: Before enabling this functionality, you must specify the routing settings using the -route_interposer* parameters of the setNanoRouteModesetNanoRouteMode command.  Data_type: bool, optional  "\fB-help\fR" Outputs a brief description that includes type and default information for each routeDesign parameter.  For a detailed description of the command and all of its parameters, use the man command: man routeDesign.  "\fB-highFrequency\fR" Runs high frequency routing. It routes high frequency digital signals to achieve critical performance.  Data_type: bool, optional  "\fB-clockEco\fR" Runs eco routing only on clock nets.   Data_type: bool, optional  "\fB-globalDetail\fR" Runs timing-driven and SI-driven global and detailed routing. -globalDetail is the default value for this command. When specified, it unfixes the clock nets and then routes all nets, including clocks that still need to be routed. It does not ECO route the clock nets prior to other signals so clock nets are not given priority as they are with routeDesign.  Note: Running the routeDesign command without the -globalDetail parameter, unfixes the clock nets and will ECO route the clock nets first before routing the remaining signal nets.  Data_type: bool, optional  "\fB-idealClock\fR" Performs timing optimization using ideal clocks instead of propagated clocks. Using ideal clocks enables you to either optimize timing without building a clock tree first, or to ignore the existing clock tree, to close ideal timing. If this parameter is not specified, the software assumes that the clock tree has been built, and optimizes timing based on propagated clocks.  Note: The -trackOpt parameter must be specified while using this parameter.  Note: When this parameter is specified, all propagated clock mode settings are reset; the setAnalysisMode -clockPropagation parameter is set to forcedIdeal.  Data_type: bool, optional  "\fB-noPlacementCheck\fR" Turns off placement checking. By default, routeDesign runs a placement check before routing and displays a warning message if the placement is not clean.   For information on the types of checks and the violation report, see checkPlace.  Data_type: bool, optional  "\fB-passiveFill\fR" Performs passive fill.  Data_type: bool, optional  "\fB-placementCheck\fR" Checks for placement violations before routing. If the placement is not clean, routeDesign display a warning message. To bypass this check use routeDesign -noPlacementCheck.  Data_type: bool, optional  "\fB-selected\fR" Routes selected nets only.  Data_type: bool, optional  "\fB-trackOpt\fR" Performs timing optimization after track assignment. Specify this option to ensure that TQuantus model file is used during timeDesign and optDesign -postRoute stages.  Note: If this parameter is specified and the TQuantus model file is missing, the TQuantus model file will be generated and set automatically. If the timing library does not exist, timing optimization will be skipped and continue routing.  For details of the TQuantus model file usage, see the "Creating RC Model Data in TQuantus Model File" section in the Using the NanoRoute Router  chapter of the Innovus User Guide.  Data_type: bool, optional  "\fB-viaOpt\fR" Optimizes vias after routing.  Warning: Exercise caution with the use of this parameter, as the router might create violations during postroute via optimization. It runs a search and repair step after optimization if violations occur.  Data_type: bool, optional  "\fB-viaPillarOpt\fR" Performs opportunistic via pillar insertion.  Note: After the design is routed or post-route optimized, the NanoRoute router looks for available tracks around the instance pin to either add a new via pillar or upgrade the original smaller via pillar to the one with more fingers. You can perform opportunistic via pillar insertion by using the routeDesign -viaPillarOpt command. After opportunistic via pillar insertion, there is no need for ecoRoute; opportunistic via pillar insertion is DRC clean by construction.  Data_type: bool, optional  "\fB-wireOpt\fR" Optimizes wires after routing. This parameter, when specified, widens and shrinks wires after detail routing has been performed. The settings specified using the following setNanoRouteMode options impact the behavior of this parameter:
.RS  "*" 2 -droutePostRouteWidenWire  "*" 2 -droutePostRouteSpreadWire  "*" 2 -droutePostRouteWidenWireRule
.RE   Data_type: bool, optional 
.SH Examples 
.SH Routing
.RS  "*" 2 To run timing- and SI-driven global and detailed routing, type the following command:  routeDesign
.RE
.RS  "*" 2 To run timing- and SI-driven global and detailed routing, type the following commands:  routeDesign -globalDetail  "*" 2 To run non-timing-driven global and detailed routing, type the following commands:  setNanoRouteMode -routeWithTimingDriven false  routeDesign -globalDetail
.RE 
.SH Postroute Yield Optimization
.RS  "*" 2 To run postroute via reduction, type the following commands:  setNanoRouteMode -drouteMinSlackForWireOptimization slack  setNanoRouteMode -droutePostRouteMinimizeViaCount true  routeDesign -viaOpt  Note : When you run these commands, the software optimize and reduce the via count. Use these commands only if no concurrent via optimization was done.
.RE
.RS  "*" 2 To run postroute single-cut via to multiple-cut via swap, type the following commands:  setNanoRouteMode -drouteMinSlackForWireOptimization <slack>setNanoRouteMode -droutePostRouteSwapVia multiCut  routeDesign -viaOpt 
.RE
.RS  "*" 2 To run non-timing-driven postroute single-cut via to multiple-cut via swap, type the following commands:  setNanoRouteMode -routeWithTimingDriven false  setNanoRouteMode -droutePostRouteSwapVia multiCut  routeDesign -viaOpt 
.RE
.RS  "*" 2 To run postroute multiple-cut via to single-cut via swap, type the following commands:  setNanoRouteMode -drouteMinSlackForWireOptimization <slack>setNanoRouteMode -droutePostRouteSwapVia singleCut  routeDesign -viaOpt
.RE
.RS  "*" 2 To run non-timing driven postroute multiple-cut via to single-cut via swap, type the following commands:  setNanoRouteMode -routeWithTimingDriven false  setNanoRouteMode -droutePostRouteSwapVia singleCut  routeDesign -viaOpt
.RE
.RS  "*" 2 To run postroute wire widening, type the following commands:  setNanoRouteMode -drouteMinSlackForWireOptimization slack  setNanoRouteMode -droutePostRouteWidenWireRule ruleName  setNanoRouteMode -droutePostRouteWidenWire widen  routeDesign -wireOpt
.RE
.RS  "*" 2 To run non-timing driven postroute wire widening, type the following commands:  setNanoRouteMode -droutePostRouteWidenWireRule ruleName  setNanoRouteMode -routeWithTimingDriven false  setNanoRouteMode -droutePostRouteWidenWire widen  routeDesign -wireOpt
.RE
.RS  "*" 2 To run postroute wire unwidening, type the following commands:  setNanoRouteMode -drouteMinSlackForWireOptimization slack  setNanoRouteMode -droutePostRouteWidenWireRule ruleName  setNanoRouteMode -droutePostRouteWidenWire shrink  routeDesign -wireOpt
.RE
.RS  "*" 2 To run non-timing-driven postroute wire unwidening, type the following commands:  setNanoRouteMode -droutePostRouteWidenWireRule ruleName  setNanoRouteMode -routeWithTimingDriven false  setNanoRouteMode -droutePostRouteWidenWire shrink  routeDesign -wireOpt
.RE
.RS  "*" 2 To run postroute wire spreading, type the following commands:  setNanoRouteMode -drouteMinSlackForWireOptimization slack  setNanoRouteMode -droutePostRouteSpreadWire true  routeDesign -wireOpt
.RE
.RS  "*" 2 To run non-timing-driven postroute wire spreading, type the following commands:  setNanoRouteMode -routeWithTimingDriven false  setNanoRouteMode -droutePostRouteSpreadWire true  routeDesign -wireOpt
.RE 
.SH Related Information
.RS  "*" 2 detailRoute  "*" 2 globalDetailRoute  "*" 2 globalRoute  "*" 2 setNanoRouteMode  "*" 2 Using the NanoRoute Router chapter in the Innovus User Guide 
.RS  "*" 2 Using the routeDesign Supercommand  "*" 2 Postroute Via Optimization
.RE  "*" 2 Accelerating the Design Process By Using Multiple-CPU Processing chapter in the Innovus User Guide
.RE
.P
